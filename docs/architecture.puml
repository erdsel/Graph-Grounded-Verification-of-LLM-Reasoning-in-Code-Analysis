@startuml system_architecture
!theme cerulean
title Graph-Grounded LLM Verification - System Architecture

skinparam componentStyle uml2
skinparam backgroundColor #FEFEFE

package "Input Layer" {
    [Python Source Code] as Input
    [Web Interface] as WebUI
    [CLI] as CLI
}

package "Analysis Engine" {
    package "Ground Truth Generation" {
        [AST Parser] as AST
        [Graph Builder] as GraphBuilder
        note right of AST
            Python ast module
            Static code analysis
        end note
    }

    package "LLM Analysis" {
        [LLM Client] as LLMClient
        [Claim Extractor] as ClaimExtractor
        note right of LLMClient
            Groq / Gemini / OpenAI
            Chain-of-Thought prompting
        end note
    }
}

package "Verification Engine" {
    [Entity Mapper] as EntityMapper
    [Verifier] as Verifier
    [Metrics Calculator] as Metrics
}

package "Output Layer" {
    [HTML Report] as Report
    [JSON API] as API
    [Graph Visualization] as GraphViz
}

database "Knowledge Store" {
    [Call Graph] as CallGraph
    [Data Flow Graph] as DFG
    [Claim Store] as Claims
}

' Connections
Input --> AST
Input --> LLMClient
WebUI --> Input
CLI --> Input

AST --> GraphBuilder
GraphBuilder --> CallGraph
GraphBuilder --> DFG

LLMClient --> ClaimExtractor
ClaimExtractor --> Claims

CallGraph --> Verifier
DFG --> Verifier
Claims --> Verifier
EntityMapper --> Verifier

Verifier --> Metrics
Metrics --> Report
Metrics --> API
Metrics --> GraphViz

@enduml

@startuml component_diagram
!theme cerulean
title Component Diagram - Module Dependencies

skinparam componentStyle uml2

package "src" {
    component "ast_parser.py" as AST {
        [ASTParser]
        [FunctionVisitor]
        [ClassVisitor]
    }

    component "graph_builder.py" as GB {
        [GraphBuilder]
        [CallGraph]
        [DataFlowGraph]
    }

    component "llm_client.py" as LLC {
        [BaseLLMClient]
        [GroqClient]
        [GeminiClient]
        [OpenAIClient]
        [MockLLMClient]
    }

    component "claim_extractor.py" as CE {
        [ClaimExtractor]
        [Claim]
        [ClaimType]
    }

    component "entity_mapper.py" as EM {
        [EntityMapper]
        [EntityMatch]
        [MatchType]
    }

    component "verifier.py" as VF {
        [Verifier]
        [VerificationResult]
        [VerificationDetail]
    }

    component "metrics.py" as MT {
        [MetricsCalculator]
    }
}

package "External Libraries" {
    component "NetworkX" as NX
    component "Groq SDK" as Groq
    component "Google GenAI" as Gemini
    component "FuzzyWuzzy" as FW
}

' Dependencies
AST --> GB : AST Result
GB --> NX : Graph Storage
LLC --> Groq
LLC --> Gemini
LLC --> CE : LLM Response
CE --> VF : Claims
EM --> FW : Fuzzy Match
EM --> VF : Entity Mapping
GB --> VF : Graph Queries
VF --> MT : Verification Results

@enduml

@startuml sequence_diagram
!theme cerulean
title Analysis Flow - Sequence Diagram

actor User
participant "Web UI" as UI
participant "Flask API" as API
participant "AST Parser" as AST
participant "Graph Builder" as GB
participant "LLM Client" as LLM
participant "Claim Extractor" as CE
participant "Verifier" as VF
participant "Metrics" as MT

User -> UI: Submit Python Code
UI -> API: POST /api/analyze
activate API

== Ground Truth Generation ==
API -> AST: parse_code(code)
activate AST
AST -> AST: Build AST
AST -> AST: Extract Functions
AST -> AST: Extract Classes
AST -> AST: Find Call Relations
AST --> API: ast_result
deactivate AST

API -> GB: build_from_ast_result()
activate GB
GB -> GB: Create Call Graph
GB -> GB: Create Data Flow Graph
GB --> API: graphs
deactivate GB

== LLM Analysis ==
API -> LLM: generate_reasoning(code)
activate LLM
LLM -> LLM: Create Prompt (JSON format)
LLM -> LLM: Call Groq/Gemini API
LLM --> API: llm_response
deactivate LLM

API -> CE: extract_claims(response)
activate CE
CE -> CE: Parse JSON
CE -> CE: Create Claim objects
CE --> API: claims[]
deactivate CE

== Verification ==
API -> VF: verify_claims(claims)
activate VF
loop For each claim
    VF -> VF: Map entities
    VF -> VF: Query graph
    VF -> VF: Classify result
end
VF --> API: verification_report
deactivate VF

== Metrics Calculation ==
API -> MT: calculate_metrics()
activate MT
MT -> MT: Compute Precision
MT -> MT: Compute Recall
MT -> MT: Compute F1
MT -> MT: Compute Hallucination Rate
MT --> API: metrics
deactivate MT

API --> UI: JSON Response
UI --> User: Display Results

@enduml

@startuml class_diagram
!theme cerulean
title Class Diagram - Core Classes

abstract class BaseLLMClient {
    +generate_reasoning(code, prompt_type): LLMResponse
    +is_available(): bool
}

class GroqClient extends BaseLLMClient {
    -api_key: str
    -model: str
    -client: Groq
    +PROMPT_TEMPLATES: dict
}

class GeminiClient extends BaseLLMClient {
    -api_key: str
    -model_name: str
    -model: GenerativeModel
}

class MockLLMClient extends BaseLLMClient {
    -call_count: int
}

class LLMResponse {
    +content: str
    +reasoning_steps: List[str]
    +model: str
    +usage: Dict
}

class ASTParser {
    +parse_code(code): Dict
    -_parse_function(): Dict
    -_parse_class(): Dict
    -_extract_calls(): List
}

class GraphBuilder {
    +call_graph: DiGraph
    +data_flow_graph: DiGraph
    +build_from_ast_result(ast_result)
    +has_call(caller, callee): bool
    +find_path(source, target): List
    +get_callees(func_name): List
}

class ClaimExtractor {
    +claims: List[Claim]
    +stats: Dict
    +extract_claims(llm_output): List[Claim]
    -_extract_from_json(): bool
    -_extract_from_text(): void
}

class Claim {
    +text: str
    +claim_type: ClaimType
    +subject: str
    +object: str
    +predicate: str
    +confidence: float
}

enum ClaimType {
    CALL
    DATA_FLOW
    EXISTENCE
    ATTRIBUTE
    UNKNOWN
}

class EntityMapper {
    +code_entities: Dict
    +entity_types: Dict
    +load_code_entities(ast_result)
    +map_entity(text_entity): EntityMatch
    -_try_exact_match(): EntityMatch
    -_try_fuzzy_match(): EntityMatch
}

class EntityMatch {
    +text_entity: str
    +code_entity: str
    +match_type: MatchType
    +confidence: float
}

enum MatchType {
    EXACT
    FUZZY
    ALIAS
    PARTIAL
    NO_MATCH
}

class Verifier {
    -graph_builder: GraphBuilder
    -entity_mapper: EntityMapper
    +verify_claims(claims): VerificationReport
    -_verify_call_claim(): VerificationDetail
    -_verify_existence_claim(): VerificationDetail
}

class VerificationDetail {
    +claim: Claim
    +result: VerificationResult
    +confidence: float
    +reason: str
}

enum VerificationResult {
    VALID
    HALLUCINATION
    UNVERIFIABLE
    PARTIALLY_VALID
}

' Relationships
BaseLLMClient <|-- GroqClient
BaseLLMClient <|-- GeminiClient
BaseLLMClient <|-- MockLLMClient
BaseLLMClient ..> LLMResponse

ClaimExtractor ..> Claim
ClaimExtractor ..> ClaimType
Claim --> ClaimType

EntityMapper ..> EntityMatch
EntityMatch --> MatchType

Verifier --> GraphBuilder
Verifier --> EntityMapper
Verifier ..> VerificationDetail
VerificationDetail --> VerificationResult
VerificationDetail --> Claim

@enduml

@startuml activity_diagram
!theme cerulean
title Verification Process - Activity Diagram

start

:Receive Python Code;

fork
    :AST Analysis;
    :Extract Functions;
    :Extract Classes;
    :Build Call Graph;
    :Build Data Flow Graph;
fork again
    :Send to LLM;
    :Parse JSON Response;
    :Extract Claims;
end fork

:For each Claim;

repeat
    :Get Claim Type;

    if (Type == CALL?) then (yes)
        :Map Caller Entity;
        :Map Callee Entity;

        if (Both entities found?) then (yes)
            :Check edge in Call Graph;

            if (Edge exists?) then (yes)
                :Mark as VALID;
                #palegreen:Correct Detection;
            else (no)
                :Check indirect path;

                if (Path exists?) then (yes)
                    :Mark as PARTIALLY_VALID;
                    #lightyellow:Indirect Relation;
                else (no)
                    :Mark as HALLUCINATION;
                    #lightcoral:False Claim!;
                endif
            endif
        else (no)
            if (Is builtin function?) then (yes)
                :Check builtin call;
            else (no)
                :Mark as UNVERIFIABLE;
            endif
        endif

    elseif (Type == EXISTENCE?) then (yes)
        :Map Entity;

        if (Entity found in code?) then (yes)
            :Mark as VALID;
        else (no)
            :Mark as HALLUCINATION;
        endif

    else (other)
        :Handle other claim types;
    endif

repeat while (More claims?) is (yes)
->no;

:Calculate Metrics;

:Generate Report;

stop

@enduml

@startuml data_flow
!theme cerulean
title Data Flow Diagram

left to right direction

rectangle "Input" {
    (Python Code) as Code
    (User Config) as Config
}

rectangle "Processing" {
    (AST Parsing) as AST
    (Graph Construction) as Graph
    (LLM Analysis) as LLM
    (Claim Extraction) as Claims
    (Entity Mapping) as Mapping
    (Verification) as Verify
    (Metrics Calculation) as Metrics
}

rectangle "Storage" {
    database "Call Graph\n(NetworkX)" as CG
    database "Data Flow Graph" as DFG
    database "Claim Store" as CS
}

rectangle "Output" {
    (JSON Response) as JSON
    (HTML Report) as HTML
    (Graph Visualization) as Viz
}

Code --> AST
Config --> LLM

AST --> Graph
Graph --> CG
Graph --> DFG

Code --> LLM
LLM --> Claims
Claims --> CS

CG --> Verify
DFG --> Verify
CS --> Verify
Mapping --> Verify

Verify --> Metrics

Metrics --> JSON
Metrics --> HTML
CG --> Viz
DFG --> Viz

@enduml
